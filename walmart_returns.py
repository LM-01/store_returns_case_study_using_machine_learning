# -*- coding: utf-8 -*-
"""walmart_returns.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U_17xTVZfBkmUUf6MedXCRZwiHBZuiDx
"""

# -*- coding: utf-8 -*-
"""
Created on Fri Aug 27 11:37:09 2021

@author: lmollinedo
"""

!pip install mlrose

import pandas as pd
import numpy as np
from math import radians, cos, sin, asin, sqrt
import math
import mlrose
import pickle

"""
Creates clusters of stores based on the distance from the primary stores, and
exports two files. One with the cluster information, and the other containing the list of 
stores in the cluster.

"""

############################# HELPERS ########################
def get_distance(lat1, lon1, lat2, lon2):
    # Returns distance between two lat/lon points in KM
    # The math module contains a function named radians which converts from degrees to radians.
    lon1 = radians(lon1)
    lon2 = radians(lon2)
    lat1 = radians(lat1)
    lat2 = radians(lat2)
 
    # Haversine formula 
    dlon = lon2 - lon1 
    dlat = lat2 - lat1 
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * asin(sqrt(a)) 
    r = 6371 # Radius of earth in kilometers. Use 3956 for miles
    
    #Display the result
    # print("Distance is: ",c*r,"Kilometers")
    return c*r

def store_sort(x):
    return x.returns

def re_arrange_path(x):
  # Finds the primary store (0), and rearranges the path \
  # so that it starts at the primary store
  zero = x.index(0)
  to_move = x[:zero]
  start = x[zero:]
  new_list = start + to_move
  return new_list

def sort_sublist(values, e_index, reverse = False):
    return values.sort(key= lambda x: x[1], reversed = reverse)

############################ END OF HELPERS #############################

# LOAD DATA
df = pd.read_csv(r'walmart_return_analysis_v2_9-7.csv')
county_data = pd.read_csv(r'cities_data.csv')
county_data['store_city'] = county_data['city'].str.upper()
states = df.store_state.unique()
merged = df.merge(county_data, left_on=['store_city','store_state'], right_on=['store_city','state_id'], how='left')

rev_per_unit = 6.51

class Store:
    def __init__(self, returns, city, state, store_num):
        self.returns = returns 
        self.city = city
        self.state = state
        self.store_number = store_num
        self.paired = False
        self.lat = 0
        self.lng = 0
        self.distance_to_primary = None
        self.store_type = None
        self.neighbor_stores = [] #sublist of [store_number, distance_to_neighbor, returns]
        self.neighbor_capacity = None
        self.store_revenue = self.returns * rev_per_unit
        self.rejected = False
      
    def reset_store(self):
      self.paired = False
      self.distance_to_primary = None
      self.store_type = None
    
    def calc_distance_to_other_store(self, other_store):
        distance = get_distance(other_store.lat, other_store.lng, self.lat, self.lng)
        if distance == 0:
          distance = 3 # Minimum store distance
        return round(distance,2)
    
    def calc_neighbor_capacity(self):
        cap = 0
        for neighbor in self.neighbor_stores:
            cap += neighbor[2]
        self.neighbor_capacity = cap
        return cap
            
class Cluster:
    def __init__(self, cluster_id):
        self.state = None
        self.primary = None
        self.satelite_stores = []
        self.all_stores_in_cluster = []
        self.cluster_returns = 0
        self.cluster_id = cluster_id
        self.miles_to_sweep = 0
        self.max_distance = 60
        self.cluster_connections = None
        self.store_cluster_id = 0
        self.optimal_path = {}
        self.path = []
        
    def assign_store_cluster_id(self):
        for i,store in enumerate(self.all_stores_in_cluster):
            store.store_cluster_id = i

    def add_primary(self, store):
        #print(f'Adding Primary: {store.store_number}')
        store.paired = True
        store.store_cluster_id = self.assign_store_cluster_id()
        self.cluster_returns += store.returns
        self.primary = store
        store.distance_to_primary = 0
        self.all_stores_in_cluster.append(store)
        
    
    def add_store(self, store):
        if store.paired == True:
            raise Exception("Cannot add a paired store to a cluster")
        if math.isnan(store.lat) or math.isnan(store.lng):
            store.rejected = True
            print(f'Did not add store {store.store_number} due to bad coordinates.')
        else:
            store.paired = True
            store.store_cluster_id = self.assign_store_cluster_id()
            self.cluster_returns += store.returns
            self.satelite_stores.append(store)
            self.all_stores_in_cluster.append(store)
            #print(f'Adding store: {store.store_number} - Cluster Returns: {self.cluster_returns}')
    
    def remove_store(self, store):
        # Removes the store from the cluster and makes it available again
        store.paired = False
        store.store_cluster_id = None
        self.cluster_returns -= store.returns
        self.satelite_stores = [storex for storex in self.satelite_stores if storex != store]
        self.all_stores_in_cluster = [self.primary] + self.satelite_stores

    def remove_last_store_added(self):
        # Removes the last store added to the cluster
        store = self.all_stores_in_cluster.pop()
        self.remove_store(store)
    
    def calc_miles_to_sweep(self):
        #Adds the miles from the primary store to all the satellite stores
        miles = 0
        for store in self.satelite_stores:
            miles += store.calc_distance_to_other_store(self.primary)
        self.miles_to_sweep = miles
        return miles

    def calc_cluster_store_distances(self):
        # Returns the distance between each of the stores in the cluster stores list
        self.assign_store_cluster_id()
        distances = []
        for i,store in enumerate(self.all_stores_in_cluster):
            for j, next_store in enumerate(self.all_stores_in_cluster):
                dist = store.calc_distance_to_other_store(next_store)
                if i == j:
                    pass
                else:
                    distances.append((store.store_cluster_id, next_store.store_cluster_id, dist))
        return distances
    
    
    def get_optimial_path(self):
        # Calculate the best optimal route for each cluster, and appends it to the "optimal_path" attributes
        # returns the best_fitness aka number of miles of the path
        routes = self.calc_cluster_store_distances()
        print(f'Getting optimal route for: {self.state} {routes}')
        if len(routes) > 1:
          self.cluster_connections = routes
          fitness_dists = mlrose.TravellingSales(distances = routes)
          problem_fit = mlrose.TSPOpt(length = len(self.all_stores_in_cluster), fitness_fn = fitness_dists,
                            maximize=False)
          # Solve problem using the genetic algorithm
          best_state, best_fitness = mlrose.genetic_alg(problem_fit, mutation_prob = 0.2, 
                          max_attempts = 100, random_state = 2)
          
          # Re-arrange paths
          best_state = re_arrange_path(best_state.tolist())
          # Translate path to store numbers
          best_state_store_nums = []
          for x in best_state:
            store_num = self.all_stores_in_cluster[x]
            best_state_store_nums.append(store_num.store_number)
          print(routes)
          print('The best state found is: ', best_state)
          print(f'Translated store#: {best_state_store_nums}')
          print('The fitness at the best state is: ', best_fitness)
          print(f'Returns for Cluster: {self.cluster_returns} --- Miles per Return: {best_fitness/self.cluster_returns}')
          self.optimal_path['cluster_optimal_route'] = best_state_store_nums
          self.optimal_path['miles_per_retun'] = best_fitness/self.cluster_returns
          self.optimal_path['route_miles'] = best_fitness
          return best_fitness

    def cluster_info(self):
        primary_store_number = self.primary.store_number
        store_nums = [store.store_number for store in self.satelite_stores]
        store_nums.insert(0, primary_store_number)
        stores_in_cluster = [str(store.store_number) for store in self.all_stores_in_cluster]
        export = [self.cluster_id, self.state, round(self.cluster_returns,2), round(self.calc_miles_to_sweep(),2), stores_in_cluster]
        # print(export)
        return export

    def cluster_export(self):
        # Retuns dictionary with the following columns:
        # Primary Store #, Satelite store locations (concat), returns of satelite stores (concat) \
        # primary returns, total cluster return, returns collection path ( concat), route miles, miles per return
        export = {}
        export['cluster_state'] = [self.state]
        export['cluster_total_returns'] = [self.cluster_returns]
        export['primary_store_number'] = [self.primary.store_number]
        export['primary_returns'] = [self.primary.returns]
        export['satellite_store_numbers'] = [str([ x.store_number for x in self.satelite_stores])]
        export['drive_order'] = [str(self.optimal_path['cluster_optimal_route'])]
        export['route_miles'] = [self.optimal_path['route_miles']]
        export['revenue_for_cluster'] = sum([store.store_revenue for store in self.all_stores_in_cluster])
        #print(export)
        return export

class Solver(Cluster, Store):
    def __init__(self, max_distance, max_returns):
        self.max_distance = max_distance
        self.max_returns = max_returns
        self.clusters = []
        self.stores_list = self.create_stores()
        self.cluster_id = 1
        self.networks = []
                
    def create_stores(self):
        stores_list = []
        for i,row in merged.iterrows():
            # print(row['Daily Returns'])
            store = Store(row['Daily Returns'],
                          row['store_city'],
                          row['store_state'],
                          row['store_number'])
            # print(store.state, store.returns)
            store.lat = row['lat']
            store.lng = row['lng']
            stores_list.append(store)
        return stores_list
    
    def find_primary_store_in_state(self, state):
        stores_in_state = self.available_stores_in_state(state)
        stores_in_state.sort(reverse=True, key=store_sort)
        if len(stores_in_state) == 0:
            return False
        primary = stores_in_state[0]
        primary.store_type = 'Primary'
        return primary
    
    def cal_distance_to_primary(self, store, primary):
        return round(get_distance(primary.lat, primary.lng, store.lat, store.lng),2)
    
    def available_stores_in_state(self, state):
        return [store for store in self.stores_list if store.state == state 
                and store.paired == False
                and store.store_type != 'Primary'
                and not math.isnan(store.lat)]
    
    def create_cluster(self):
        cluster = Cluster(self.cluster_id)
        self.cluster_id += 1
        return cluster

    def run(self):
        # Will clear the clusters and create new routes based on specifications
        # Saves the existing clusters in the archived clusters file
        self.archived_clusters = self.clusters
        self.clusters = []
        for state in states:
            #print(f'Running solver for: {state}')
            if state not in ['AK','CA','HI']:
              loop_run = True
              while loop_run:
                  primary = self.find_primary_store_in_state(state)
                  if primary != False:
                      cluster = self.create_cluster()
                      cluster.state = state
                      cluster.add_primary(primary)
                      stores_in_state = self.available_stores_in_state(state)
                      for store in stores_in_state:
                          store.distance_to_primary = self.cal_distance_to_primary(store, primary)
                          #### ORIGINAL METHOD - DO NOT DELETE YET ##########
                          #if store.distance_to_primary < self.max_distance and cluster.cluster_returns < self.max_returns:
                          if store.distance_to_primary < self.max_distance:
                              cluster.add_store(store)
                      self.clusters.append(cluster)
                  else:
                      loop_run = False
              else:
                pass
            
    def run_v2(self):
        # Will clear the clusters and create new routes based on specifications
        # Saves the existing clusters in the archived clusters file
        # self.archived_clusters = self.clusters
        self.clusters = []
        for state in states:
            if state not in ['AK','CA','HI']:
            #TESTING FOR FL
            #if state == 'FL':
              print(f'Running solver for: {state}')
              loop_run = True
              while loop_run:
                  primary = self.find_primary_store_in_state(state)
                  if primary != False:
                      # Create a cluster and add a primary
                      cluster = self.create_cluster()
                      cluster.state = state
                      cluster.add_primary(primary)
                      stores_in_state = self.available_stores_in_state(state)
                      # Calculate distance from primary store for every store
                      for store in stores_in_state:
                          store.distance_to_primary = self.cal_distance_to_primary(store, primary)
                      # Calculate ratio                     
                      building_cluster = True
                      while building_cluster:
                        store_to_evaluate = cluster.all_stores_in_cluster[-1]
                        print(f'Evaluating store {store_to_evaluate.store_number}')
                        # if store_to_evaluate.store_number == 1436:
                        #     print('Wait')
                        next_stores = self.calculate_ratio(state, store_to_evaluate)
                        ### CALCULATE OPTIMAL PATH HERE ###
                        
                        ###################################
                        if len(next_stores) <= 2:
                          # Close the cluster if there are not enough stores 
                            print(f'Length is {len(next_stores)}')
                            loop_run = False
                            building_cluster = False
                        else:
                            cluster.add_store(next_stores[0][0])
                            path_miles = cluster.get_optimial_path()
                            # Limits cluster to max 50 miles for the optimal path
                            if path_miles > 50:
                              cluster.remove_last_store_added()
                              path_miles = cluster.get_optimial_path()
                              building_cluster = False
                        if path_miles == None or path_miles >= 50:
                            building_cluster = False

                      self.clusters.append(cluster)
                  else:
                      loop_run = False
              else:
                pass
            
    def calculate_ratio(self,state, source_store):
        # Calculates the ratio from a "source_store" to all available stores and returns the top one
        available_stores = self.available_stores_in_state(state)
        ratios = []
        for i, dest_store in enumerate(available_stores):
            #print(i)
            ratio = round(dest_store.returns / (source_store.calc_distance_to_other_store(dest_store) + dest_store.distance_to_primary),5)
            ratios.append([dest_store, ratio])
        ratios = [x for x in ratios if not math.isnan(x[1])]
        ratios.sort(reverse = True, key=lambda x: x[1])
        stores = [pair for pair in ratios if not math.isnan(pair[0].lat)]
        print(source_store.store_number , len(ratios))
        return stores

    def export(self):
        print('Printing Export')
        # Exports cluster information
        e_columns =['cluster_id','state','cluster_returns','miles_to_sweep','stores_in_cluster']
        cluster_data = []
        store_data = []
        for cluster in self.clusters:
            cluster_data.append(cluster.cluster_info())
        df1 = pd.DataFrame(data=cluster_data, columns=e_columns)
        #print(df1.tail(50))
        df1.to_csv('exports/cluster_list.csv',index=False)
        
        # Cluster ID , Store
        # Exports stores list for each cluster
        clusterinfo = []
        cluster_columns = ['cluster_id','store_number','store_returns']
        for cluster in self.clusters:
            data = [cluster.cluster_id, cluster.primary.store_number, cluster.primary.returns]
            clusterinfo.append(data)
            for store in cluster.satelite_stores:
                data = [cluster.cluster_id, store.store_number, store.returns]
                clusterinfo.append(data)
        df2 = pd.DataFrame(data=clusterinfo, columns=cluster_columns)
        #print(df2.tail(50))
        df2.to_csv(r'exports/cluster_store_list.csv',index=False)

# Calculate the optimal path
def calculate_optimal_paths():
  routes = []
  cluster_exports = []
  for i,cluster in enumerate(solver.clusters):
    if i != None:
      #print(i)
      best_route = []
      connections = cluster.get_optimial_path()
      if len(cluster.all_stores_in_cluster) > 1:
        exports = cluster.cluster_export()
        cluster_exports.append(exports)
  return cluster_exports

#with open('/content/solver-saved', 'rb') as file:
#  solver = pickle.load(file)

def save_model():
  filename = 'solver-saved-v2'
  outfile = open(filename, 'wb')
  pickle.dump(solver,outfile)
  outfile.close()
  print('Model Saved!')

def update_store_data():
  new_store_data = pd.read_csv(r'wm_stores_v2.csv')
  new_store_data.dropna(inplace=True)
  new_store_data['Zip Code'] = new_store_data['Zip Code'].astype(int)
  new_store_data.info()
  # Adds in the new values to the existing model
  for i,cluster in enumerate(solver.clusters):
    for j,store in enumerate(cluster.all_stores_in_cluster):
      #if i == 0 and j == 0:
      row = new_store_data.loc[new_store_data['store_number'] == store.store_number]
      if not row.empty and row['LAT'].values[0] != 0:
        zip = row['Zip Code'].values[0]
        returns = row['Daily Returns'].values[0]
        lat = row['LAT'].values[0]
        lng = row['LNG'].values[0]
        store.returns = returns
        store.zip_code = zip
        store.lat = lat
        store.lng = lng

def test_new_inport():
  test_store = solver.clusters[0].all_stores_in_cluster[2]

def full_store_list():
  #Returns an array with all the stores available in solver and clusters
  stores = []
  for i,cluster in enumerate(solver.clusters):
    for j,store in enumerate(cluster.all_stores_in_cluster):
      stores.append(store)
  return stores

stores = full_store_list()
test_store = [store for store in stores if store.store_number == 5293]

len(solver.stores_list)

solver.stores_list = full_store_list()

"""Running the new process here.

1.   Create new clusters and add stores based on the new requirements
2.   run the optimzation path
3.   save the file


"""

solver = Solver(50,1000)
update_store_data()
solver.run_v2()
save_model()

# Just exporting the data
routes = []
cluster_exports = []
for i,cluster in enumerate(solver.clusters):
  if len(cluster.all_stores_in_cluster) > 1:
    exports = cluster.cluster_export()
    cluster_exports.append(exports)

data_frame = pd.DataFrame(cluster_exports)
data_frame.to_csv('results_optimized_stores.csv', index=False)

print('Done')

save_model()

